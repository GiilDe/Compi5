%{
    #include "parser.h"
%}

%token            VOID
%token            INT
%token            BYTE
%token            B
%token            BOOL
%left             OR
%left             AND
%right            NOT
%token            TRUE
%token            FALSE
%token            RETURN
%token            IF
%token            ELSE
%token            WHILE
%token            BREAK
%token            CONTINUE
%token            PRECOND
%token            SC
%token            COMMA
%token            LPAREN
%token            RPAREN
%token            LBRACE
%token            RBRACE
%right            ASSIGN
%nonassoc         RELOP
%left             BINOP
%token            ID
%token            NUM
%token            STRING
%token            EF

%%

Program	:	Funcs EF
        {
         verifyMainFunction();
         exit_last_scope();
         code_buffer->printCodeBuffer();
         exit(0);
        }
        ;

Funcs	:	/*epsilon*/
		|	FuncDecl Funcs
	    ;


FuncDecl	:	RetType ID LPAREN {new_scope();} Formals RPAREN PreConditions LBRACE {
                current_return_type = dynamic_cast<Type*>($1)->type;
                addFunctionDeclaration($1, $2, $5);
            } Statements RBRACE
            {
                exit_scope(true, $2, $7);
            }
	        ;

RetType	:	Type
            { $$ = new Type(static_cast<Type*>($1)->type); }

		|	VOID
		    { $$ = new Type(VOID); }
	    ;

Formals	:	/*epsilon*/
        { $$ = new TypesList(); }

		|	FormalsList
		{
            $$ = new TypesList();
            vector<int>& params = static_cast<TypesList*>($$)->params;
            vector<int>& params_other = static_cast<TypesList*>($1)->params;
            params = params_other;
		}
	    ;

FormalsList	:	FormalDecl
            {
                $$ = new TypesList();
                Type* t = static_cast<Type*>($1);
                static_cast<TypesList*>($$)->params.push_back(t->type);
            }
			|	FormalDecl COMMA FormalsList
			{
                $$ = new TypesList();
                vector<int>& params = static_cast<TypesList*>($$)->params;
                vector<int>& params_other = static_cast<TypesList*>($3)->params;
                params.push_back(static_cast<Type*>($1)->type);
                params.insert(params.end(), params_other.begin(), params_other.end());
			}
			;

FormalDecl	:	Type ID
            {
                tryAddVariable($1, $2, true);
                $$ = new Type(static_cast<Type*>($1)->type);
	        }
            ;

PreConditions	:	/*epsilon*/
                {$$ = new Preconditions(0);}
				|	PreConditions PreCondition
				{
				 int num = static_cast<Preconditions*>($1)->preconditions_num;
				 $$ = new Preconditions(num + 1);
				}
	            ;

PreCondition	:	PRECOND LPAREN Exp {verifyType($3, BOOL);} RPAREN
                    {$$ = new Preconditions(0);}
	            ;

Statements	:	Statement
			|	Statements Statement
	        ;

Statement: Open_statement
         | Closed_statement
         ;

Open_statement: If_Start M Simple_statement
                {
                    string after_if_label = code_buffer->genLabel();
                    string label_true = dynamic_cast<Label*>($2)->label;
                    Type* t = dynamic_cast<Type*>($1);
                    code_buffer->bpatch(t->true_list, label_true);
                    code_buffer->bpatch(t->false_list, after_if_label);
                    exit_scope(false, NULL, NULL);
                }

              | If_Start M Open_statement
                {
                    string after_if_label = code_buffer->genLabel();
                    string label_true = dynamic_cast<Label*>($2)->label;
                    Type* t = dynamic_cast<Type*>($1);
                    code_buffer->bpatch(t->true_list, label_true);
                    code_buffer->bpatch(t->false_list, after_if_label);
                    exit_scope(false, NULL, NULL);
                }

              | If_Else Open_statement
                {
                    Type *t = dynamic_cast<Type*>($1);
                    string exit_label = code_buffer->genLabel();
                    code_buffer->bpatch(t->exit_list, exit_label);
                    exit_scope(false, NULL, NULL);
                }

              | While_Start Open_statement
                {
                    exit_scope(false, NULL, NULL);
                    while_start* ws = dynamic_cast<while_start*>($1);
                    string exp_evaluation_label = dynamic_cast<Label*>(ws->v[0])->label;
                    Type* exp = dynamic_cast<Type*>(ws->v[1]);
                    string label_true = dynamic_cast<Label*>($2)->label;
                    code_buffer->bpatch(exp->true_list, label_true);
                    code_buffer->emit("j " + exp_evaluation_label);
                    string after_while = code_buffer->genLabel();
                    code_buffer->bpatch(exp->false_list, after_while);
                }
              ;

Closed_statement: Simple_statement
                | If_Else Closed_statement
                  {
                    Type *t = dynamic_cast<Type*>($1);
                    string exit_label = code_buffer->genLabel();
                    code_buffer->bpatch(t->exit_list, exit_label);
                    exit_scope(false, NULL, NULL);
                  }

                | While_Start M Closed_statement
                  {
                    exit_scope(false, NULL, NULL);
                    while_start* ws = dynamic_cast<while_start*>($1);
                    string exp_evaluation_label = dynamic_cast<Label*>(ws->v[0])->label;
                    Type* exp = dynamic_cast<Type*>(ws->v[1]);
                    string label_true = dynamic_cast<Label*>($2)->label;
                    code_buffer->bpatch(exp->true_list, label_true);
                    code_buffer->emit("j " + exp_evaluation_label);
                    string after_while = code_buffer->genLabel();
                    code_buffer->bpatch(exp->false_list, after_while);
                  }
                ;

While_Start: WHILE {in_while++;} LPAREN M Exp RPAREN
{
    verifyType($5, BOOL);
    new_scope();
    $$ = new while_start();
    while_start* ws = dynamic_cast<while_start*>($$);
    ws->v.push_back($4);
    ws->v.push_back($5);
}

If_Start: IF LPAREN Exp RPAREN
{
    verifyType($3, BOOL); new_scope();
    $$ = $3;
}

If_Else: If_Start M Closed_statement N {exit_scope(false, NULL, NULL);} ELSE {new_scope();} M
{
    string label_true = dynamic_cast<Label*>($2)->label;
    string label_false = dynamic_cast<Label*>($8)->label;
    Type* if_exp = dynamic_cast<Type*>($1);
    code_buffer->bpatch(if_exp->true_list, label_true);
    code_buffer->bpatch(if_exp->false_list, label_false);

    int exit_address = dynamic_cast<Num*>($4)->val;
    $$ = new Type();
    Type* t = dynamic_cast<Type*>($$);
    t->exit_list.push_back(exit_address);
}



Simple_statement:  LBRACE {new_scope();} Statements RBRACE
                  {
                   exit_scope(false, NULL, NULL);
                  }

                | Type ID SC
                  {tryAddVariable($1, $2, false);}

                | Type ID ASSIGN Exp SC
                  {
                    Type *t = dynamic_cast<Type*>($4);
                    verifyType($1, t->type);
                    tryAddVariable($1, $2, false);
                    get_ID_reg($2);
                    Id* id = static_cast<Id*>($2);
                    string dest = id->type.reg;
                    Type *t1 = dynamic_cast<Type*>($1);
                    if(static_cast<tokens>(t1->type) != BOOL){
                        move_data(dest, t->reg);
                    }
                    else{
                        bool_assignment(dest, t);
                    }
                  }

                | ID ASSIGN Exp SC
                {
                    verifyIdType($1, $3);
                    verifyVariableDefined($1);
                    get_ID_reg($1);
                    Id* id = static_cast<Id*>($1);
                    string dest = id->type.reg;
                    Type* t = static_cast<Type*>($3);
                    if(getVariableType($1) != BOOL)
                        move_data(dest, t->reg);
                    else{
                        bool_assignment(dest, t);
                    }
                }
                | Call SC
                | RETURN SC
                {
                    verifyReturn(VOID);
                    int type = static_cast<int>(VOID);
                }
                | RETURN Exp SC
                {
                    int type = static_cast<Type*>($2)->type;
                    verifyReturn(type);
                }
                | BREAK SC
                {
                    verifyBreak();
                    $$ = new Type(static_cast<int>(VOID));
                }

                | CONTINUE SC
                { verifyContinue(); }
                ;

Call	:	ID LPAREN ExpList RPAREN
            {
                verifyFunctionDefined($1);
                $$ = new Type(getFunctionReturnType($1));
                verifyRightParams($1, $3);
            }

		|	ID LPAREN RPAREN
		    {
		        verifyFunctionDefined($1);
		        $$ = new Type(getFunctionReturnType($1));
		        TypesList* empty = new TypesList();
                verifyRightParams($1, empty);
		    }
	    ;

ExpList	:	Exp
        {
            int type = static_cast<Type*>($1)->type;
            vector<int> v;
            v.push_back(type);
            $$ = new TypesList(v);
        }
		|	Exp COMMA ExpList
		{
            int type = static_cast<Type*>($1)->type;
            vector<int> v1;
            v1.push_back(type);
            $$ = new TypesList(v1);
            vector<int>& v = static_cast<TypesList*>($$)->params;
            vector<int>& exp = static_cast<TypesList*>($3)->params;
            v.insert(v.end(), exp.begin(), exp.end());
		}
	    ;

Type	:	INT
        { $$ = new Type(INT); }

		|	BYTE
		{ $$ = new Type(BYTE); }

		|	BOOL
		{ $$ = new Type(BOOL); }
	    ;

Exp	:	LPAREN Exp RPAREN
    {
        $$ = new Type(static_cast<Type*>($2)->type);
        Type* b = static_cast<Type*>($$);
        Type* b1 = static_cast<Type*>($2);
        b->bool_exp = b1->bool_exp;
        if(b1->bool_exp){
            b->true_list = b1->true_list;
            b->false_list = b1->false_list;
        }
    }

	|	Exp BINOP Exp
	{
        int t1 = verifyTypes($1, 3, NUM, BYTE, INT);
        int t2 = verifyTypes($3, 3, NUM, BYTE, INT);

        // Try NUM precision first, retreat to byte if both are BYTE
        int preciseType = t1 == NUM ? NUM : (t2 == NUM ? NUM : BYTE);
        $$ = new Type(preciseType);

        Type* dest = static_cast<Type*>($$);
        Type* Rsrc = static_cast<Type*>($1);
        Type* src = static_cast<Type*>($3);
        dest->reg = get_free_register();
        string binops = static_cast<Binop*>($2)->op;
        binop(dest, Rsrc, src, binops);
    }

	|	ID
    {
        verifyVariableDefined($1);
        Id* id = static_cast<Id*>($1);
        get_ID_reg($1);
        $$ = new Type(getVariableType($1), id->type.reg);
    }

	|	Call
	{ $$ = $1; }

	|	NUM
	{
      $$ = new Type(NUM);
      int num = dynamic_cast<Num*>($1)->val;
      Type* dest = static_cast<Type*>($$);
      dest->reg = int_to_string(num);
    }

	|	NUM B
	{
	    verifyByteSize($1);
	    $$ = new Type(BYTE);
	}

	|	STRING
	{ $$ = new Type(STRING); }

	|	TRUE
	{
	    $$ = new Type(BOOL);
	    Type* b = static_cast<Type*>($$);
	    b->bool_exp = true;
	    b->true_list.push_back(code_buffer->emit("j "));
	}

	|	FALSE
	{
	    $$ = new Type(BOOL);
        Type* b = static_cast<Type*>($$);
        b->bool_exp = false;
        b->false_list.push_back(code_buffer->emit("j "));
	}

	|	NOT Exp
	{
    	verifyType($2, BOOL);
        $$ = new Type(BOOL);

        Type* b = static_cast<Type*>($$);
        Type* b1 = static_cast<Type*>($2);

        b->bool_exp = true;
        b->false_list = b1->true_list;
        b->true_list = b1->false_list;
    }
	|	Exp AND M Exp
	{
	    verifyType($1, BOOL);
	    verifyType($3, BOOL);
        $$ = new Type(BOOL);

        Type* b = static_cast<Type*>($$);
        b->bool_exp = true;

        Type* b1 = static_cast<Type*>($1);
        Type* b2 = static_cast<Type*>($4);
        string label = static_cast<Label*>($3)->label;
        code_buffer->bpatch(b1->true_list, label);
        b->false_list = code_buffer->merge(b1->false_list, b2->false_list);
        b->true_list = b2->true_list;
    }
	|	Exp OR M Exp
	{
	    verifyType($1, BOOL);
     	verifyType($3, BOOL);
        $$ = new Type(BOOL);
        Type* b = static_cast<Type*>($$);
        b->bool_exp = true;

        Type* b1 = static_cast<Type*>($1);
        Type* b2 = static_cast<Type*>($4);
        string label = static_cast<Label*>($3)->label;
        code_buffer->bpatch(b1->false_list, label);
        b->true_list = code_buffer->merge(b1->true_list, b2->true_list);
        b->false_list = b2->false_list;
    }
	|	Exp RELOP Exp
	{
	    verifyTypes($1, 3, NUM, BYTE, INT);
	    verifyTypes($3, 3, NUM, BYTE, INT);
	    $$ = new Type(BOOL);
        Type* b = static_cast<Type*>($$);
        b->bool_exp = true;
        Type* b1 = static_cast<Type*>($1);
        Type* b2 = static_cast<Type*>($3);
        string r = static_cast<Binop*>($2)->op;
        string reg1 = get_reg_if_mem(b1);
        string reg2 = get_reg_if_mem(b2);

        if(r == ">="){
            b->true_list.push_back(code_buffer->emit("bge " + reg1 + ", " + reg2 + " "));
        }
        else if(r == ">"){
            b->true_list.push_back(code_buffer->emit("bgt " + reg1 + ", " + reg2 + " "));
        }
        else if(r == "<="){
            b->true_list.push_back(code_buffer->emit("ble " + reg1 + ", " + reg2 + " "));
        }
        else if(r == "<"){
            b->true_list.push_back(code_buffer->emit("blt " + reg1 + ", " + reg2 + " "));
        }
        else if(r == "<"){
            b->true_list.push_back(code_buffer->emit("blt " + reg1 + ", " + reg2 + " "));
        }
        else if(r == "=="){
            b->true_list.push_back(code_buffer->emit("beq " + reg1 + ", " + reg2 + " "));
        }
        else if(r == "!="){
            b->true_list.push_back(code_buffer->emit("bne " + reg1 + ", " + reg2 + " "));
        }
        b->false_list.push_back(code_buffer->emit("j "));

        if(reg1 != b1->reg){
            free_register(reg1);
        }
        if(reg2 != b2->reg){
            free_register(reg2);
        }
	}
	;

M   : /*epsilon*/ {$$ = new Label(code_buffer->genLabel());}
N   : /*epsilon*/ {$$ = new Num(code_buffer->emit("j "));}


%%
